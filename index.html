<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>プレゼンタイマー</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Digital Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- Base Styles -->
    <style>
        body {
            touch-action: manipulation;
            overscroll-behavior: none;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background-color: rgba(156, 163, 175, 0.5);
            border-radius: 20px;
        }
        /* Digital Display Font */
        .digital-font {
            font-family: 'Share Tech Mono', monospace;
            letter-spacing: 0.05em;
            font-feature-settings: 'tnum' 1;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const IconBase = ({ children, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Pause = (props) => <IconBase {...props}><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></IconBase>;
        const Plus = (props) => <IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></IconBase>;
        const Clock = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
        const AlertCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></IconBase>;
        const Volume2 = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>;
        const Maximize = (props) => <IconBase {...props}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></IconBase>;
        const Palette = (props) => <IconBase {...props}><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.01 17.461 2 12 2z"/></IconBase>;
        const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const ArrowsUpDown = (props) => <IconBase {...props}><path d="M17 3l4 4-4 4M7 13l-4 4 4 4M3 17h18M21 7H3"/></IconBase>;

        // --- Web Worker Code ---
        const workerCode = `
        let intervalId;
        self.onmessage = function(e) {
          if (e.data === 'start') {
            if (!intervalId) {
              intervalId = setInterval(() => {
                postMessage('tick');
              }, 100);
            }
          } else if (e.data === 'stop') {
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = null;
            }
          }
        };
        `;

        // --- Themes ---
        const THEMES = {
            indigo: {
                name: 'Indigo',
                bg: 'bg-indigo-600',
                bgLight: 'bg-indigo-50',
                bgMedium: 'bg-indigo-100',
                text: 'text-indigo-600',
                textDark: 'text-indigo-800',
                border: 'border-indigo-100',
                borderActive: 'border-indigo-500',
                accent: 'accent-indigo-600',
                button: 'bg-indigo-600 hover:bg-indigo-700 shadow-indigo-200',
                progress: 'bg-indigo-500',
                landscapeBg: 'bg-indigo-900/40',
                landscapeFill: 'bg-indigo-600/90',
            },
            emerald: {
                name: 'Forest',
                bg: 'bg-emerald-600',
                bgLight: 'bg-emerald-50',
                bgMedium: 'bg-emerald-100',
                text: 'text-emerald-600',
                textDark: 'text-emerald-800',
                border: 'border-emerald-100',
                borderActive: 'border-emerald-500',
                accent: 'accent-emerald-600',
                button: 'bg-emerald-600 hover:bg-emerald-700 shadow-emerald-200',
                progress: 'bg-emerald-500',
                landscapeBg: 'bg-emerald-900/40',
                landscapeFill: 'bg-emerald-600/90',
            },
            rose: {
                name: 'Sunset',
                bg: 'bg-rose-600',
                bgLight: 'bg-rose-50',
                bgMedium: 'bg-rose-100',
                text: 'text-rose-600',
                textDark: 'text-rose-800',
                border: 'border-rose-100',
                borderActive: 'border-rose-500',
                accent: 'accent-rose-600',
                button: 'bg-rose-600 hover:bg-rose-700 shadow-rose-200',
                progress: 'bg-rose-500',
                landscapeBg: 'bg-rose-900/40',
                landscapeFill: 'bg-rose-600/90',
            }
        };

        const App = () => {
            // --- State ---
            const [timers, setTimers] = useState(() => {
                try {
                    const saved = localStorage.getItem('presentation-timer-settings');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return parsed.map(t => ({ ...t, triggered: false }));
                    }
                } catch (e) {
                    console.warn('Failed to load timer settings', e);
                }
                // デフォルト値を「区間時間」に変更 (8分 + 2分 = 10分)
                return [
                    { id: 1, minutes: 8, label: '予鈴まで', triggered: false },
                    { id: 2, minutes: 2, label: '終了', triggered: false },
                ];
            });

            const [currentThemeKey, setCurrentThemeKey] = useState(() => {
                return localStorage.getItem('presentation-timer-theme') || 'indigo';
            });

            const [soundEnabled, setSoundEnabled] = useState(() => {
                const saved = localStorage.getItem('presentation-timer-sound');
                return saved !== null ? saved === 'true' : true;
            });

            const [isRunning, setIsRunning] = useState(false);
            const [elapsedMs, setElapsedMs] = useState(0);
            const [notificationPermission, setNotificationPermission] = useState('default');
            const [hasError, setHasError] = useState(false);
            const [isFlashing, setIsFlashing] = useState(false);
            const [viewMode, setViewMode] = useState('editor');
            const [longPressTimer, setLongPressTimer] = useState(null);
            const [deletingTimerId, setDeletingTimerId] = useState(null);
            const [holdIntervalTimer, setHoldIntervalTimer] = useState(null);

            const theme = THEMES[currentThemeKey];

            // --- Refs ---
            const workerRef = useRef(null);
            const fallbackIntervalRef = useRef(null);
            const startTimeRef = useRef(null);
            const offsetTimeRef = useRef(0);
            const audioCtxRef = useRef(null);
            const prevMinuteRef = useRef(0);

            // --- Initialization ---
            useEffect(() => {
                let workerUrl;
                try {
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    workerUrl = URL.createObjectURL(blob);
                    const worker = new Worker(workerUrl);
                    worker.onmessage = () => {
                        if (!startTimeRef.current) return;
                        const current = Date.now();
                        const diff = current - startTimeRef.current + offsetTimeRef.current;
                        setElapsedMs(diff);
                    };
                    workerRef.current = worker;
                } catch (e) {
                    console.warn("Web Worker fallback", e);
                }

                try {
                    if ('Notification' in window) {
                        setNotificationPermission(Notification.permission);
                    }
                } catch (e) {}

                const handleResize = () => {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    const isMobileLandscape = width < 1024 && width > height;
                    if (isMobileLandscape) {
                        setViewMode('fullscreen');
                    } else if (width < 1024 && height > width) {
                        setViewMode('editor');
                    }
                };
                handleResize();
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (workerRef.current) workerRef.current.terminate();
                    if (fallbackIntervalRef.current) clearInterval(fallbackIntervalRef.current);
                    if (workerUrl) URL.revokeObjectURL(workerUrl);
                    if (audioCtxRef.current) try { audioCtxRef.current.close(); } catch(e){}
                };
            }, []);

            // --- Persistence ---
            useEffect(() => {
                try { localStorage.setItem('presentation-timer-settings', JSON.stringify(timers)); } catch (e) {}
            }, [timers]);

            useEffect(() => {
                localStorage.setItem('presentation-timer-theme', currentThemeKey);
            }, [currentThemeKey]);

            useEffect(() => {
                localStorage.setItem('presentation-timer-sound', soundEnabled);
            }, [soundEnabled]);

            // --- Audio ---
            const initAudio = () => {
                try {
                    if (!audioCtxRef.current) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (AudioContext) audioCtxRef.current = new AudioContext();
                    }
                    if (audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
                        audioCtxRef.current.resume().catch(e => {});
                    }
                } catch (e) {}
            };

            const playChime = (count = 1) => {
                if (!soundEnabled) return;
                try {
                    if (!audioCtxRef.current) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (AudioContext) audioCtxRef.current = new AudioContext();
                    }
                    const ctx = audioCtxRef.current;
                    if (!ctx) return;

                    const now = ctx.currentTime;
                    const gap = 0.6;
                    for (let i = 0; i < count; i++) {
                        const startTime = now + i * gap;
                        const oscillator = ctx.createOscillator();
                        const gainNode = ctx.createGain();

                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, startTime); 
                        oscillator.frequency.exponentialRampToValueAtTime(440, startTime + 0.1);

                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);

                        oscillator.connect(gainNode);
                        gainNode.connect(ctx.destination);

                        oscillator.start(startTime);
                        oscillator.stop(startTime + 0.6);
                    }
                } catch (e) {}
            };

            const sendNotification = (title, body) => {
                try {
                    if (!('Notification' in window)) return;
                    if (Notification.permission === 'granted') {
                        new Notification(title, { body });
                    }
                } catch (e) {}
            };

            // --- Logic (Relay Mode) ---
            useEffect(() => {
                try {
                    // 累積時間を計算しながらチェック
                    let accumulatedMinutes = 0;
                    
                    timers.forEach((timer, index) => {
                        // このタイマーの終了時刻 (累積)
                        const targetMinutes = accumulatedMinutes + timer.minutes;
                        const targetMs = targetMinutes * 60 * 1000;
                        
                        // トリガー判定
                        if (!timer.triggered && elapsedMs >= targetMs) {
                            playChime(index + 2); 
                            sendNotification('プレゼンタイマー', `${timer.label}の時間になりました`);
                            setTimers(prev => prev.map(t => 
                                t.id === timer.id ? { ...t, triggered: true } : t
                            ));
                        }
                        
                        accumulatedMinutes += timer.minutes;
                    });

                    // 1分ごとの処理 (全体時間に対して)
                    const currentMinute = Math.floor(elapsedMs / 60000);
                    if (currentMinute > 0 && currentMinute > prevMinuteRef.current) {
                        // 累積時間を再計算して、タイマー発火タイミングと重なるかチェック
                        let accCheck = 0;
                        const isTimerTriggerMatch = timers.some(t => {
                            accCheck += t.minutes;
                            return accCheck === currentMinute;
                        });

                        if (!isTimerTriggerMatch) {
                            playChime(1);
                        }
                        setIsFlashing(true);
                        setTimeout(() => setIsFlashing(false), 200);
                        setTimeout(() => setIsFlashing(true), 400);
                        setTimeout(() => setIsFlashing(false), 600);
                    }
                    prevMinuteRef.current = currentMinute;

                } catch (e) {
                    setHasError(true);
                }
            }, [elapsedMs, timers]);

            const requestNotificationPermission = async () => {
                try {
                    if (!('Notification' in window)) return;
                    const permission = await Notification.requestPermission();
                    setNotificationPermission(permission);
                } catch (e) {}
            };

            const handleStart = () => {
                initAudio();
                if (notificationPermission === 'default') requestNotificationPermission();

                if (!isRunning) {
                    startTimeRef.current = Date.now();
                    setIsRunning(true);
                    setHasError(false);
                    if (workerRef.current) {
                        workerRef.current.postMessage('start');
                    } else {
                        fallbackIntervalRef.current = setInterval(() => {
                            if (!startTimeRef.current) return;
                            const current = Date.now();
                            const diff = current - startTimeRef.current + offsetTimeRef.current;
                            setElapsedMs(diff);
                        }, 100);
                    }
                }
            };

            const handlePause = () => {
                if (isRunning) {
                    if (workerRef.current) workerRef.current.postMessage('stop');
                    if (fallbackIntervalRef.current) {
                        clearInterval(fallbackIntervalRef.current);
                        fallbackIntervalRef.current = null;
                    }
                    offsetTimeRef.current = elapsedMs;
                    setIsRunning(false);
                    startTimeRef.current = null;
                }
            };

            const handleReset = () => {
                if (workerRef.current) workerRef.current.postMessage('stop');
                if (fallbackIntervalRef.current) {
                    clearInterval(fallbackIntervalRef.current);
                    fallbackIntervalRef.current = null;
                }
                setIsRunning(false);
                setElapsedMs(0);
                offsetTimeRef.current = 0;
                startTimeRef.current = null;
                prevMinuteRef.current = 0;
                setTimers(prev => prev.map(t => ({ ...t, triggered: false })));
                setHasError(false);
            };

            const addTimer = () => {
                const newId = Math.max(...timers.map(t => t.id), 0) + 1;
                // デフォルトで5分追加
                setTimers([...timers, { id: newId, minutes: 5, label: `タイマー ${timers.length + 1}`, triggered: false }]);
            };

            const removeTimer = (id) => {
                setTimers(timers.filter(t => t.id !== id));
            };

            const handleLongPressStart = (id) => {
                if (isRunning || timers.length <= 1) return;
                const timer = setTimeout(() => {
                    setDeletingTimerId(null);
                    removeTimer(id);
                }, 800);
                setLongPressTimer(timer);
                setDeletingTimerId(id);
            };

            const handleLongPressEnd = () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    setLongPressTimer(null);
                }
                setDeletingTimerId(null);
            };

            const handleButtonHoldStart = (id, operation) => {
                // 即座に1回実行
                if (operation === 'increment') {
                    updateTimer(id, 'minutes', Math.min(60, timers.find(t => t.id === id).minutes + 1));
                } else {
                    updateTimer(id, 'minutes', Math.max(1, timers.find(t => t.id === id).minutes - 1));
                }
                
                // 300ms後から連続実行開始
                const initialTimeout = setTimeout(() => {
                    const interval = setInterval(() => {
                        setTimers(prevTimers => {
                            const timer = prevTimers.find(t => t.id === id);
                            if (!timer) return prevTimers;
                            
                            let newMinutes;
                            if (operation === 'increment') {
                                newMinutes = Math.min(60, timer.minutes + 1);
                            } else {
                                newMinutes = Math.max(1, timer.minutes - 1);
                            }
                            
                            if (newMinutes === timer.minutes) {
                                return prevTimers;
                            }
                            
                            return prevTimers.map(t => t.id === id ? { ...t, minutes: newMinutes, triggered: false } : t);
                        });
                    }, 100);
                    setHoldIntervalTimer(interval);
                }, 300);
                
                setLongPressTimer(initialTimeout);
            };

            const handleButtonHoldEnd = () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    setLongPressTimer(null);
                }
                if (holdIntervalTimer) {
                    clearInterval(holdIntervalTimer);
                    setHoldIntervalTimer(null);
                }
            };

            const updateTimer = (id, key, value) => {
                setTimers(timers.map(t => t.id === id ? { ...t, [key]: value, triggered: false } : t));
            };

            const resetTimersToDefault = () => {
                setTimers([
                    { id: 1, minutes: 8, label: '予鈴まで', triggered: false },
                    { id: 2, minutes: 2, label: '終了', triggered: false },
                ]);
            };

            const toggleTheme = () => {
                const keys = Object.keys(THEMES);
                const currentIndex = keys.indexOf(currentThemeKey);
                const nextIndex = (currentIndex + 1) % keys.length;
                setCurrentThemeKey(keys[nextIndex]);
            };

            const toggleFullscreen = async () => {
                try {
                    if (!document.fullscreenElement) {
                        await document.documentElement.requestFullscreen();
                    } else {
                        await document.exitFullscreen();
                    }
                } catch (e) {
                    console.warn('Fullscreen error:', e);
                }
            };

            const formatTime = (ms) => {
                if (isNaN(ms) || ms < 0) return "00:00";
                const totalSeconds = Math.floor(ms / 1000);
                const m = Math.floor(totalSeconds / 60);
                const s = totalSeconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            // 全体の合計時間を計算
            const totalMinutes = timers.reduce((acc, t) => acc + t.minutes, 0);
            const totalDurationMs = totalMinutes * 60 * 1000;
            const totalProgress = totalDurationMs > 0 ? Math.min((elapsedMs / totalDurationMs) * 100, 100) : 100;

            // 現在のタイマーラベルの取得 (リレー方式)
            let currentLabel = '完了';
            let nextRemaining = 0;
            let tempAcc = 0;
            for (let i = 0; i < timers.length; i++) {
                const t = timers[i];
                const startMs = tempAcc * 60 * 1000;
                const endMs = (tempAcc + t.minutes) * 60 * 1000;
                if (elapsedMs < endMs) {
                    currentLabel = t.label;
                    nextRemaining = endMs - elapsedMs;
                    break;
                }
                tempAcc += t.minutes;
            }

            const currentMinute = Math.floor(elapsedMs / 60000);

            if (hasError) {
                return (
                    <div className="min-h-screen flex items-center justify-center bg-red-50 text-red-600 p-4">
                        <div className="text-center">
                            <AlertCircle className="w-12 h-12 mx-auto mb-4" />
                            <p className="font-bold">エラーが発生しました</p>
                            <button onClick={() => window.location.reload()} className="mt-4 px-4 py-2 bg-red-600 text-white rounded-lg">再読み込み</button>
                        </div>
                    </div>
                );
            }

            // --- EDITOR MODE ---
            if (viewMode === 'editor') {
                let accumulatedMinutes = 0; // 表示用累積カウンタ

                return (
                    <div className="min-h-screen bg-slate-50 font-sans selection:bg-slate-200 flex flex-col items-center">
                        <div className="w-full max-w-md min-h-screen flex flex-col shadow-2xl bg-white relative">
                            
                            <header className={`relative ${theme.bg} text-white p-6 pt-10 rounded-b-[2rem] shadow-lg z-10 transition-colors duration-500`}>
                                <div className="flex justify-between items-center mb-6">
                                    <h1 className="text-2xl font-bold flex items-center gap-2">
                                        <Clock className="w-6 h-6" />
                                        プレゼンタイマー
                                    </h1>
                                    
                                    <div className="hidden sm:flex items-center gap-2">
                                        {!isRunning && (
                                            <button onClick={resetTimersToDefault} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors" title="初期値に戻す">
                                                <RotateCcw className="w-4 h-4 text-white" />
                                            </button>
                                        )}
                                        <button onClick={toggleTheme} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors">
                                            <Palette className="w-4 h-4 text-white" />
                                        </button>
                                        <button onClick={() => setViewMode('fullscreen')} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors" title="横向き表示">
                                            <ArrowsUpDown className="w-4 h-4 text-white" />
                                        </button>
                                        <button onClick={toggleFullscreen} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors" title="フルスクリーン">
                                            <Maximize className="w-4 h-4 text-white" />
                                        </button>
                                    </div>
                                </div>
                                <div className="text-center mb-2">
                                    <div className="text-sm opacity-80 mb-1 font-medium tracking-wider">ELAPSED TIME</div>
                                    <div className="text-7xl font-mono font-bold tracking-tighter tabular-nums text-white drop-shadow-md">
                                        {formatTime(elapsedMs)}
                                    </div>
                                    <div className="text-xs text-white/70 mt-1">合計予定: {totalMinutes}分</div>
                                </div>
                                
                                {/* アラーム音設定 */}
                                <div className="flex items-center justify-center gap-2 mt-4 pb-2">
                                    <Volume2 className="w-4 h-4 text-white/70" />
                                    <button 
                                        onClick={() => setSoundEnabled(!soundEnabled)} 
                                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                                            soundEnabled ? 'bg-white/30' : 'bg-white/10'
                                        }`}
                                    >
                                        <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                                            soundEnabled ? 'translate-x-6' : 'translate-x-1'
                                        }`} />
                                    </button>
                                    <span className="text-xs text-white/70">{soundEnabled ? 'ON' : 'OFF'}</span>
                                </div>
                            </header>

                            {/* スマホ時のボタン */}
                            <div className="absolute top-6 right-6 z-20 sm:hidden">
                                <div className="flex items-center gap-2">
                                    {!isRunning && (
                                        <button onClick={resetTimersToDefault} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors" title="初期値に戻す">
                                            <RotateCcw className="w-4 h-4 text-white" />
                                        </button>
                                    )}
                                    <button onClick={toggleTheme} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors">
                                        <Palette className="w-4 h-4 text-white" />
                                    </button>
                                    <button onClick={() => setViewMode('fullscreen')} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors" title="横向き表示">
                                        <ArrowsUpDown className="w-4 h-4 text-white" />
                                    </button>
                                    <button onClick={toggleFullscreen} className="p-2 bg-white/20 rounded-full hover:bg-white/30 transition-colors" title="フルスクリーン">
                                        <Maximize className="w-4 h-4 text-white" />
                                    </button>
                                </div>
                            </div>

                            <main className="flex-1 p-6 space-y-6 overflow-y-auto pb-32">
                                {timers.map((timer, index) => {
                                    // この区間の開始時間(ms)と終了時間(ms)
                                    const startMs = accumulatedMinutes * 60 * 1000;
                                    const durationMs = timer.minutes * 60 * 1000;
                                    const endMs = startMs + durationMs;
                                    
                                    // この区間の進捗
                                    // 区間に入る前: 0, 区間中: 割合, 区間後: 100
                                    let progress = 0;
                                    if (elapsedMs >= endMs) {
                                        progress = 100;
                                    } else if (elapsedMs > startMs) {
                                        progress = ((elapsedMs - startMs) / durationMs) * 100;
                                    }

                                    const isActive = (elapsedMs >= startMs && elapsedMs < endMs);
                                    const isCompleted = elapsedMs >= endMs;
                                    
                                    // 残り時間表示
                                    const remainingInThisSection = Math.max(0, endMs - elapsedMs);
                                    
                                    // 次のループのために累積
                                    accumulatedMinutes += timer.minutes;

                                    return (
                                        <div 
                                            key={timer.id} 
                                            className={`relative overflow-hidden rounded-xl border-2 transition-all duration-300 min-h-[100px] flex items-stretch ${
                                                isCompleted ? `${theme.border} ${theme.bgLight}` : 
                                                isActive ? `${theme.borderActive} shadow-md bg-white` : 
                                                'border-slate-100 bg-slate-50 opacity-60'
                                            } ${deletingTimerId === timer.id ? 'scale-95 opacity-50' : ''}`}
                                            onMouseDown={() => handleLongPressStart(timer.id)}
                                            onMouseUp={handleLongPressEnd}
                                            onMouseLeave={handleLongPressEnd}
                                            onTouchStart={() => handleLongPressStart(timer.id)}
                                            onTouchEnd={handleLongPressEnd}
                                            onTouchCancel={handleLongPressEnd}
                                        >
                                            <div className={`absolute top-0 left-0 h-full transition-all duration-100 ease-linear ${isCompleted ? `${theme.bgMedium} opacity-50` : theme.bgMedium}`} style={{ width: isCompleted ? '100%' : `${progress}%` }} />
                                            
                                            {/* 左：マイナスボタン（20%） */}
                                            {!isRunning && (
                                                <button 
                                                    onMouseDown={(e) => {
                                                        e.stopPropagation();
                                                        if (timer.minutes > 1) handleButtonHoldStart(timer.id, 'decrement');
                                                    }}
                                                    onMouseUp={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    onMouseLeave={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    onTouchStart={(e) => {
                                                        e.stopPropagation();
                                                        if (timer.minutes > 1) handleButtonHoldStart(timer.id, 'decrement');
                                                    }}
                                                    onTouchEnd={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    onTouchCancel={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    disabled={timer.minutes <= 1}
                                                    className={`relative z-10 flex items-center justify-center text-3xl font-bold transition-colors ${
                                                        timer.minutes <= 1 ? `${theme.bgLight} text-slate-300 cursor-not-allowed` : `${theme.bgLight} ${theme.text} hover:${theme.bgMedium} active:opacity-70`
                                                    }`}
                                                    style={{ width: '20%' }}
                                                >
                                                    −
                                                </button>
                                            )}
                                            
                                            <div className="relative z-10 flex-1 p-4 pointer-events-none">
                                                <div className="flex justify-between items-center mb-1">
                                                    <div className="flex items-center gap-3 flex-1 min-w-0">
                                                        <div className={`flex items-center justify-center w-8 h-8 rounded-full text-xs font-bold shrink-0 shadow-sm transition-colors duration-300 ${isActive ? (isCompleted ? `${theme.bg} text-white` : `bg-white ${theme.text} ring-2 ring-current`) : 'bg-slate-200 text-slate-500'}`}>
                                                            {index + 1}
                                                        </div>
                                                        <div className="flex-1 min-w-0">
                                                            {isRunning ? (
                                                                <div className="font-bold text-xl text-slate-800 truncate leading-tight">{timer.label}</div>
                                                            ) : (
                                                                <input 
                                                                    type="text" 
                                                                    className={`w-full p-1 text-lg font-bold border-b border-transparent focus:border-current outline-none text-slate-800 placeholder-slate-400 bg-transparent ${theme.text} pointer-events-auto`} 
                                                                    value={timer.label} 
                                                                    placeholder="ラベル名" 
                                                                    onChange={(e) => updateTimer(timer.id, 'label', e.target.value)}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                    onTouchStart={(e) => e.stopPropagation()}
                                                                />
                                                            )}
                                                            <div className="text-xs text-slate-500 font-medium">
                                                                区間: {timer.minutes}分
                                                            </div>
                                                        </div>
                                                    </div>

                                                    {isRunning && isActive && !isCompleted && (
                                                        <div className={`font-mono text-2xl font-bold tabular-nums ${theme.text}`}>{formatTime(remainingInThisSection)}</div>
                                                    )}
                                                    {isCompleted && (
                                                        <div className={`font-bold flex items-center gap-1 ${theme.textDark}`}>完了</div>
                                                    )}
                                                </div>
                                            </div>
                                            
                                            {/* 右：プラスボタン（20%） */}
                                            {!isRunning && (
                                                <button 
                                                    onMouseDown={(e) => {
                                                        e.stopPropagation();
                                                        if (timer.minutes < 60) handleButtonHoldStart(timer.id, 'increment');
                                                    }}
                                                    onMouseUp={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    onMouseLeave={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    onTouchStart={(e) => {
                                                        e.stopPropagation();
                                                        if (timer.minutes < 60) handleButtonHoldStart(timer.id, 'increment');
                                                    }}
                                                    onTouchEnd={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    onTouchCancel={(e) => {
                                                        e.stopPropagation();
                                                        handleButtonHoldEnd();
                                                    }}
                                                    disabled={timer.minutes >= 60}
                                                    className={`relative z-10 flex items-center justify-center text-3xl font-bold transition-colors ${
                                                        timer.minutes >= 60 ? `${theme.bgLight} text-slate-300 cursor-not-allowed` : `${theme.bgLight} ${theme.text} hover:${theme.bgMedium} active:opacity-70`
                                                    }`}
                                                    style={{ width: '20%' }}
                                                >
                                                    +
                                                </button>
                                            )}
                                        </div>
                                    );
                                })}

                                {!isRunning && (
                                    <button onClick={addTimer} className={`w-full py-4 border-2 border-dashed border-slate-300 rounded-xl text-slate-400 hover:${theme.text} hover:border-current hover:${theme.bgLight} transition-all flex items-center justify-center gap-2 font-medium`}>
                                        <Plus className="w-5 h-5" />
                                        次を追加
                                    </button>
                                )}
                            </main>

                            <div className="absolute bottom-8 left-0 right-0 flex justify-center items-center gap-6 px-6 z-20 pointer-events-none">
                                <div className="flex items-center gap-6 pointer-events-auto">
                                    <div className={`transition-all duration-300 transform ${(!isRunning && elapsedMs > 0) ? 'scale-100 opacity-100' : 'scale-0 opacity-0 w-0'}`}>
                                        <button onClick={handleReset} className="flex items-center justify-center w-14 h-14 rounded-full bg-slate-200 text-slate-600 shadow-lg hover:bg-slate-300 active:scale-95 transition-all"><RotateCcw className="w-6 h-6" /></button>
                                    </div>
                                    <button onClick={isRunning ? handlePause : handleStart} className={`flex items-center justify-center w-20 h-20 rounded-full shadow-xl text-white transition-all transform hover:scale-105 active:scale-95 ${isRunning ? 'bg-amber-400 hover:bg-amber-500 shadow-amber-200' : theme.button}`}>
                                        {isRunning ? <Pause className="w-10 h-10 fill-current" /> : <Play className="w-10 h-10 fill-current ml-1" />}
                                    </button>
                                    <div className={`transition-all duration-300 transform ${(!isRunning && elapsedMs > 0) ? 'w-14' : 'w-0'}`}></div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // --- FULLSCREEN MODE ---
            if (viewMode === 'fullscreen') {
                return (
                    <div className="fixed inset-0 z-50 bg-slate-900 text-white flex flex-col overflow-hidden font-sans">
                        <div className={`absolute top-0 left-0 h-full ${theme.landscapeFill} shadow-[0_0_50px_rgba(255,255,255,0.2)] transition-all duration-300 ease-linear z-0`} style={{ width: `${totalProgress}%` }} />
                        <div className={`absolute top-0 left-0 h-full bg-white transition-opacity duration-150 ease-out pointer-events-none z-10`} style={{ width: `${totalProgress}%`, opacity: isFlashing ? 0.6 : 0 }} />
                        
                        <div className="absolute inset-0 w-full h-full flex z-20 pointer-events-none">
                            {totalMinutes > 0 && Array.from({ length: totalMinutes }).map((_, i) => {
                                const minuteIndex = i + 1;
                                const isPassed = minuteIndex <= currentMinute;
                                return (
                                    <div key={`grid-${i}`} className={`absolute top-0 bottom-0 border-r transition-all duration-500 ${isPassed ? 'border-white/60 shadow-[0_0_8px_rgba(255,255,255,0.5)]' : 'border-white/10'}`} style={{ left: `${(minuteIndex / totalMinutes) * 100}%` }} />
                                );
                            })}
                            
                            {timers.map((timer, index) => {
                                // 描画位置の計算 (累積ベース)
                                const prevMins = timers.slice(0, index).reduce((acc, t) => acc + t.minutes, 0);
                                const duration = timer.minutes;
                                const widthPercent = (duration / totalMinutes) * 100;
                                
                                return (
                                    <div key={timer.id} style={{ width: `${widthPercent}%` }} className="h-full border-r-4 border-white/50 relative group">
                                        <div className="absolute bottom-2 right-2 text-xs md:text-sm font-medium text-white/50 group-hover:text-white/80 transition-colors pointer-events-auto">
                                            {timer.minutes}分: {timer.label}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        <div className="relative z-30 flex-1 flex flex-col items-center justify-center p-8 pointer-events-none">
                            <div className="font-bold mb-2 text-white/90 drop-shadow-md tracking-wider" style={{ fontSize: '20vh', lineHeight: '1' }}>
                                {currentLabel}
                            </div>
                            <div className="digital-font font-black leading-none tabular-nums drop-shadow-2xl text-white" style={{ fontSize: '50vh', lineHeight: '1' }}>
                                {formatTime(elapsedMs)}
                            </div>
                        </div>

                        {/* 右上：ボタン（全デバイス） */}
                        <div className="absolute top-6 right-6 z-40 flex items-center gap-3">
                            <button onClick={() => setViewMode('editor')} className="w-12 h-12 rounded-full bg-slate-800/80 hover:bg-slate-700 text-white flex items-center justify-center backdrop-blur-sm shadow-lg transition-all active:scale-95 pointer-events-auto" title="設定画面">
                                <ArrowsUpDown className="w-5 h-5" />
                            </button>
                            <button onClick={toggleFullscreen} className="w-12 h-12 rounded-full bg-slate-800/80 hover:bg-slate-700 text-white flex items-center justify-center backdrop-blur-sm shadow-lg transition-all active:scale-95 pointer-events-auto" title="フルスクリーン">
                                <Maximize className="w-5 h-5" />
                            </button>
                        </div>

                        {/* 左下：操作ボタン（全デバイス） */}
                        <div className="absolute bottom-6 left-6 z-40 flex items-center gap-4">
                            <button onClick={isRunning ? handlePause : handleStart} className={`w-16 h-16 rounded-full flex items-center justify-center shadow-xl backdrop-blur-sm transition-all active:scale-95 pointer-events-auto ${isRunning ? 'bg-amber-500/90 hover:bg-amber-500 text-white' : `${theme.bg} text-white`}`}>
                                {isRunning ? <Pause className="w-8 h-8 fill-current" /> : <Play className="w-8 h-8 fill-current ml-1" />}
                            </button>
                            {!isRunning && elapsedMs > 0 && (
                                <button onClick={handleReset} className="w-14 h-14 rounded-full bg-slate-800/80 hover:bg-slate-700 text-white flex items-center justify-center backdrop-blur-sm shadow-lg transition-all active:scale-95 pointer-events-auto"><RotateCcw className="w-6 h-6" /></button>
                            )}
                        </div>

                        {/* スマホ横向き時の操作ボタン（左下） */}
                        <div className="absolute bottom-6 left-6 z-40 flex sm:hidden items-center gap-4">
                            <button onClick={isRunning ? handlePause : handleStart} className={`w-16 h-16 rounded-full flex items-center justify-center shadow-xl backdrop-blur-sm transition-all active:scale-95 pointer-events-auto ${isRunning ? 'bg-amber-500/90 hover:bg-amber-500 text-white' : `${theme.bg} text-white`}`}>
                                {isRunning ? <Pause className="w-8 h-8 fill-current" /> : <Play className="w-8 h-8 fill-current ml-1" />}
                            </button>
                            {!isRunning && elapsedMs > 0 && (
                                <button onClick={handleReset} className="w-14 h-14 rounded-full bg-slate-800/80 hover:bg-slate-700 text-white flex items-center justify-center backdrop-blur-sm shadow-lg transition-all active:scale-95 pointer-events-auto"><RotateCcw className="w-6 h-6" /></button>
                            )}
                        </div>
                    </div>
                );
            }

            return null;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>